<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width">
    <link rel="stylesheet" href="css/leaflet.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jjimenezshaw/Leaflet.Control.Layers.Tree@master/L.Control.Layers.Tree.css">
    <link rel="stylesheet" href="css/qgis2web.css">
    <link rel="stylesheet" href="css/fontawesome-all.min.css">
    <link rel="stylesheet" href="css/leaflet.photon.css">
    <style>
        html, body, #kakao-map, #map { width: 100%; height: 100%; padding: 0; margin: 0; }
        #kakao-map, #map { position: absolute; top: 0; left: 0; right: 0; bottom: 0; }
        #kakao-map { z-index: 0; }
        #map { z-index: 1; background: transparent; }

        /* 1. 팝업창 디자인 (가로 넓히기 + 파란 테두리 + 북동쪽 배치를 위한 여백) */
        .leaflet-popup-content-wrapper {
            width: 450px !important; 
            border: 3px solid #0000ff !important;
            background: #ffffff !important;
            border-radius: 10px;
            box-shadow: 3px 3px 10px rgba(0,0,0,0.2);
        }
        .leaflet-popup-content {
            width: 420px !important;
            color: #000000 !important;
            font-size: 14px;
        }
        .leaflet-popup-content table { width: 100%; border-collapse: collapse; }
        .leaflet-popup-content th { min-width: 110px; text-align: left; padding: 5px; }
        .leaflet-popup-content td { padding: 5px; word-break: break-all; }

        /* 2. 라벨(툴팁) 디자인 */
        .leaflet-tooltip.css_map_data {
            background-color: #ffffff !important;
            border: 2px solid #0000ff !important;
            color: #000000 !important;
            font-weight: bold;
            padding: 8px 12px;
            border-radius: 6px;
            max-width: none !important;
            width: max-content;
        }

        .popup-field-toggle {
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 10px;
            border-radius: 4px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        .labels-hidden .leaflet-tooltip-pane { display: none; }
    </style>
</head>
<body>
        <div id="kakao-map"></div>
        <div id="map"></div>
        <script src="js/qgis2web_expressions.js"></script>
        <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=231190ac1aca72ada0b739110d8a0eb4"></script>
        <script src="js/leaflet.js"></script>
        <script src="js/kakao_base.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/jjimenezshaw/Leaflet.Control.Layers.Tree@master/L.Control.Layers.Tree.js"></script>
        <script src="js/leaflet.rotatedMarker.js"></script>
        <script src="js/leaflet.pattern.js"></script>
        <script src="js/leaflet-hash.js"></script>
        <script src="js/Autolinker.min.js"></script>
        <script src="js/rbush.min.js"></script>
        <script src="js/labelgun.min.js"></script>
        <script src="js/labels.js"></script>
        <script src="js/leaflet.photon.js"></script>
        <script src="data/map_data.js"></script>
        <script>
        var map = L.map('map', {
            zoomControl:false, maxZoom:28, minZoom:1
        }).fitBounds([[37.43966984122166,126.86818683641245],[37.6101521616503,127.1412179712234]]);
        // Kakao Roadmap(일반지도/Street) 배경지도 초기화 + Leaflet 뷰 동기화
        initKakaoBaseMap(map, { mapTypeId: 'ROADMAP' });
        var hash = new L.Hash(map);
        map.attributionControl.setPrefix('<a href="https://github.com/tomchadwin/qgis2web" target="_blank">qgis2web</a> &middot; <a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a> &middot; <a href="https://qgis.org">QGIS</a>');
        var autolinker = new Autolinker({truncate: {length: 30, location: 'smart'}});

        // 팝업에 표시할 필드(속성)별 토글 설정
        var popupFieldConfig_map_data = (function() {
            var fields = [
                '감정서번호', '본사/지사', '담당자', '평가사', '건명', '거래처명', '의뢰인', '상태',
                '의뢰일자', '발송일자', '소유자전화', '채무자', '채무자전화', '의뢰문서번', '의뢰부서',
                '제출처', '제출처(Tar', '제출처(T_1', '제출처(T_2', '소유자', '평가목적', '물건종류',
                '주소', '지번주소', '위도', '경도', '지번주소(2', '위도(2)', '경도(2)'
            ];
            var vis = {};
            for (var i = 0; i < fields.length; i++) vis[fields[i]] = true; // 기본: 모두 표시
            return { fields: fields, visible: vis };
        })();

        // 라벨(지도 위 텍스트)에 표시할 필드별 토글 설정
        // - qgis2web 기본 라벨식: 제출처(Tar) / 담당자 / 의뢰일자 / 상태 / 주소
        var labelFieldConfig_map_data = (function() {
            var fields = ['제출처(Tar', '담당자', '의뢰일자', '상태', '주소'];
            var vis = {};
            for (var i = 0; i < fields.length; i++) vis[fields[i]] = true;
            return { fields: fields, visible: vis };
        })();

        function buildPopupContent_map_data(feature) {
            function fmt(v) {
                if (v === null || v === undefined) return '';
                return autolinker.link(String(v).replace(/'/g, '\'').toLocaleString());
            }
            var rows = '';
            var cfg = popupFieldConfig_map_data;
            for (var i = 0; i < cfg.fields.length; i++) {
                var key = cfg.fields[i];
                if (!cfg.visible[key]) continue;
                var val = feature.properties[key];
                if (val === null || val === undefined || val === '') continue;
                rows += '<tr><th>' + key + '</th><td>' + fmt(val) + '</td></tr>';
            }
            return '<table>' + (rows || '<tr><td>표시할 속성이 없습니다.</td></tr>') + '</table>';
        }

        function buildLabelContent_map_data(feature) {
            var cfg = labelFieldConfig_map_data;
            var props = feature && feature.properties ? feature.properties : feature;
            if (!props) return '';
            var parts = [];
            for (var i = 0; i < cfg.fields.length; i++) {
                var key = cfg.fields[i];
                if (!cfg.visible[key]) continue;
                var v = props[key];
                if (v === null || v === undefined || v === '') continue;
                parts.push(String(v));
            }
            if (!parts.length) return '';
            var multi = parts.length > 1;
            var cls = multi ? 'q2w-label q2w-label--multi' : 'q2w-label q2w-label--single';
            var sep = multi ? '\n' : ' ';
            return '<div class="' + cls + '" style="color:#ffffff; font-size:10pt; font-family:\'Open Sans\', sans-serif;">' +
                parts.join(sep) +
                '</div>';
        }
        // remove popup's row if "visible-with-data"
        function removeEmptyRowsFromPopupContent(content, feature) {
         var tempDiv = document.createElement('div');
         tempDiv.innerHTML = content;
         var rows = tempDiv.querySelectorAll('tr');
         for (var i = 0; i < rows.length; i++) {
             var td = rows[i].querySelector('td.visible-with-data');
             var key = td ? td.id : '';
             if (td && td.classList.contains('visible-with-data') && feature.properties[key] == null) {
                 rows[i].parentNode.removeChild(rows[i]);
             }
         }
         return tempDiv.innerHTML;
        }
        // modify popup if contains media
        function addClassToPopupIfMedia(content, popup) {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            var imgTd = tempDiv.querySelector('td img');
            if (imgTd) {
                var src = imgTd.getAttribute('src');
                if (/\.(jpg|jpeg|png|gif|bmp|webp|avif)$/i.test(src)) {
                    popup._contentNode.classList.add('media');
                    setTimeout(function() {
                        popup.update();
                    }, 10);
                } else if (/\.(mp3|wav|ogg|aac)$/i.test(src)) {
                    var audio = document.createElement('audio');
                    audio.controls = true;
                    audio.src = src;
                    imgTd.parentNode.replaceChild(audio, imgTd);
                    popup._contentNode.classList.add('media');
                    setTimeout(function() {
                        popup.setContent(tempDiv.innerHTML);
                        popup.update();
                    }, 10);
                } else if (/\.(mp4|webm|ogg|mov)$/i.test(src)) {
                    var video = document.createElement('video');
                    video.controls = true;
                    video.src = src;
                    video.style.width = "400px";
                    video.style.height = "300px";
                    video.style.maxHeight = "60vh";
                    video.style.maxWidth = "60vw";
                    imgTd.parentNode.replaceChild(video, imgTd);
                    popup._contentNode.classList.add('media');
                    // Aggiorna il popup quando il video carica i metadati
                    video.addEventListener('loadedmetadata', function() {
                        popup.update();
                    });
                    setTimeout(function() {
                        popup.setContent(tempDiv.innerHTML);
                        popup.update();
                    }, 10);
                } else {
                    popup._contentNode.classList.remove('media');
                }
            } else {
                popup._contentNode.classList.remove('media');
            }
        }
        var zoomControl = L.control.zoom({
            position: 'topleft'
        }).addTo(map);
        var bounds_group = new L.featureGroup([]);
        function setBounds() {
        }
        function pop_map_data(feature, layer) {
			layer.on('popupopen', function(e) {
				addClassToPopupIfMedia(e.popup.getContent(), e.popup);
			});
			layer.bindPopup(function() {
                return buildPopupContent_map_data(feature);
            }, { maxHeight: 400 });
        }

        function style_map_data_0() {
            return {
                pane: 'pane_map_data',
                radius: 4.0,
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1,
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(133,182,111,1.0)',
                interactive: true,
            }
        }
        map.createPane('pane_map_data');
        map.getPane('pane_map_data').style.zIndex = 400;
        map.getPane('pane_map_data').style['mix-blend-mode'] = 'normal';
		       var layer_map_data = new L.geoJson(json_map_data, {
		    attribution: '',
		    interactive: true,
		    dataVar: 'json_map_data',
		    layerName: 'layer_map_data',
		    pane: 'pane_map_data',
		    onEachFeature: function(feature, layer) {
		        // 1. 기존 팝업 함수 실행
		        pop_map_data(feature, layer);
		        
		        // 2. 팝업 옵션 동적 수정 (가로 넓이 및 북동쪽 위치)
		        if (layer.getPopup()) {
		            layer.getPopup().setOptions({
		                maxWidth: 500,           // 최대 가로 너비 확장
		                minWidth: 400,           // 최소 가로 너비 확보
		                offset: L.point(150, 0), // [가로, 세로] 가로 150px만큼 오른쪽(동측) 이동
		                className: 'custom-popup' // CSS 제어를 위한 클래스명 추가
		            });
		        }
		    },
		    pointToLayer: function (feature, latlng) {
		        var context = {
		            feature: feature,
		            variables: {}
		        };
		        // 3. 마커 크기 키우기: radius 값을 기존보다 크게 설정 (예: 13)
		        return L.circleMarker(latlng, {
		            pane: 'pane_map_data',
		            radius: 13.0,            // 여기서 숫자를 키우면 마커가 커집니다!
		            opacity: 1,
		            color: 'rgba(35,35,35,1.0)', // 테두리 색상
		            dashArray: '',
		            lineCap: 'butt',
		            lineJoin: 'miter',
		            weight: 1.0,
		            fill: true,
		            fillOpacity: 1,
		            fillColor: 'rgba(255,0,0,1.0)', // 채우기 색상
		            interactive: true,
		        });
		    },
		});
        bounds_group.addLayer(layer_map_data);
        map.addLayer(layer_map_data);
        
        // QGIS 데이터(오버레이) 토글 컨트롤
        // - 마커(피처)와 텍스트(라벨)를 분리 토글합니다.
        // - 라벨은 Leaflet tooltip pane을 숨기는 "토글용 레이어"로 구현합니다.
        var LabelToggleLayer = L.Layer.extend({
            onAdd: function(m) {
                m.getContainer().classList.remove('labels-hidden');
            },
            onRemove: function(m) {
                m.getContainer().classList.add('labels-hidden');
            }
        });
        var layer_labels_map_data = new LabelToggleLayer();
        // 기본값: 라벨 표시(체크된 상태)
        layer_labels_map_data.addTo(map);

        L.control.layers(
            null,
            {
                '마커': layer_map_data,
                '텍스트(라벨)': layer_labels_map_data
            },
            { collapsed: false, position: 'topright' }
        ).addTo(map);

        // 라벨(텍스트) 필드별 표시/숨김 토글 컨트롤
        (function addLabelFieldToggleControl() {
            var Control = L.Control.extend({
                options: { position: 'topright' },
                onAdd: function(m) {
                    var div = L.DomUtil.create('div', 'popup-field-toggle');
                    div.innerHTML = [
                        '<div class="title">라벨 필드 토글</div>',
                        '<div class="actions">',
                        '  <button type="button" data-action="all">전체</button>',
                        '  <button type="button" data-action="none">해제</button>',
                        '</div>',
                        '<div class="list"></div>'
                    ].join('');

                    L.DomEvent.disableClickPropagation(div);
                    L.DomEvent.disableScrollPropagation(div);

                    var list = div.querySelector('.list');
                    var cfg = labelFieldConfig_map_data;

                    function refreshLabels() {
                        var idx = 0;
                        layer_map_data.eachLayer(function(lyr) {
                            var tt = (lyr.getTooltip && lyr.getTooltip()) ? lyr.getTooltip() : null;
                            if (tt) {
                                tt.setContent(buildLabelContent_map_data(lyr.feature));
                            }
                            idx++;
                        });
                        // labelgun 재계산
                        resetLabels([layer_map_data]);
                    }

                    for (var i = 0; i < cfg.fields.length; i++) {
                        var key = cfg.fields[i];
                        var id = 'labelfield_' + i;
                        var row = document.createElement('label');
                        row.innerHTML = '<input type="checkbox" id="' + id + '" checked> <span>' + key + '</span>';
                        (function(k, checkbox) {
                            checkbox.addEventListener('change', function() {
                                cfg.visible[k] = !!checkbox.checked;
                                refreshLabels();
                            });
                        })(key, row.querySelector('input'));
                        list.appendChild(row);
                    }

                    div.querySelector('[data-action="all"]').addEventListener('click', function() {
                        for (var i = 0; i < cfg.fields.length; i++) cfg.visible[cfg.fields[i]] = true;
                        var inputs = list.querySelectorAll('input[type="checkbox"]');
                        for (var j = 0; j < inputs.length; j++) inputs[j].checked = true;
                        refreshLabels();
                    });
                    div.querySelector('[data-action="none"]').addEventListener('click', function() {
                        for (var i = 0; i < cfg.fields.length; i++) cfg.visible[cfg.fields[i]] = false;
                        var inputs = list.querySelectorAll('input[type="checkbox"]');
                        for (var j = 0; j < inputs.length; j++) inputs[j].checked = false;
                        refreshLabels();
                    });

                    return div;
                }
            });
            map.addControl(new Control());
        })();
        setBounds();
        var i = 0;
        layer_map_data.eachLayer(function(layer) {
            var context = {
                feature: layer.feature,
                variables: {}
            };
            // 라벨은 필드별 토글 설정을 반영해 생성
            layer.bindTooltip(buildLabelContent_map_data(layer.feature), {permanent: true, offset: [-0, -16], className: 'css_map_data'});
            labels.push(layer);
            totalMarkers += 1;
              layer.added = true;
              addLabel(layer, i);
              i++;
        });
        resetLabels([layer_map_data]);
        map.on("zoomend", function(){
            resetLabels([layer_map_data]);
        });
        map.on("layeradd", function(){
            resetLabels([layer_map_data]);
        });
        map.on("layerremove", function(){
            resetLabels([layer_map_data]);
        });
        </script>        
    </body>
</html>
