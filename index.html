<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <link rel="stylesheet" href="css/leaflet.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jjimenezshaw/Leaflet.Control.Layers.Tree@master/L.Control.Layers.Tree.css">
        <link rel="stylesheet" href="css/qgis2web.css">
        <link rel="stylesheet" href="css/fontawesome-all.min.css">
        <link rel="stylesheet" href="css/leaflet.photon.css">
        <style>
        html, body, #kakao-map, #map {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
        }
        /* 카카오지도를 배경으로 두고, Leaflet은 그 위에 오버레이로 올립니다. */
        #kakao-map, #map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        #kakao-map {
            z-index: 0;
        }
        #map {
            z-index: 1;
            background: transparent;
        }
        /* 팝업(속성표) 가독성 개선 */
        .leaflet-popup-content table {
            border-collapse: collapse;
            width: 100%;
        }
        .leaflet-popup-content th,
        .leaflet-popup-content td {
            padding: 2px 6px;
            vertical-align: top;
            word-break: break-word;
            white-space: normal;
        }
        .leaflet-popup-content th {
            text-align: left;
            font-weight: 600;
            white-space: nowrap;
            opacity: 0.85;
        }
        /* 팝업 필드 토글 컨트롤 UI */
        .popup-field-toggle {
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 10px;
            border-radius: 4px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.3);
            max-height: 45vh;
            overflow: auto;
            font: 12px/1.2 Arial, Helvetica, sans-serif;
        }
        .popup-field-toggle .title {
            font-weight: 700;
            margin-bottom: 6px;
        }
        .popup-field-toggle .actions {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
        }
        .popup-field-toggle .actions button {
            font-size: 11px;
            padding: 2px 6px;
            cursor: pointer;
        }
        .popup-field-toggle label {
            display: flex;
            gap: 6px;
            align-items: center;
            margin: 3px 0;
            cursor: pointer;
            user-select: none;
        }
        /* 라벨(툴팁) 폭/줄바꿈 제어 */
        .leaflet-tooltip.css_map_data {
            /* 기본 leaflet max-width 때문에 글자가 세로로 꺾이는 현상 방지 */
            max-width: none !important;
            width: max-content; /* 가능하면 내용만큼 가로로 확장 */
            white-space: normal; /* 실제 줄바꿈은 내부 .q2w-label이 제어 */

			color: #000000 !important;      /* 글자색을 검정으로 */
        	font-weight: bold;              /* (선택) 글자를 더 진하게 하려면 추가 */
    		text-shadow: 1px 1px 2px white; /* (선택) 검은 글씨가 더 잘 보이게 흰색 외곽선 추가 */
        }
        .leaflet-tooltip.css_map_data .q2w-label {
			color: #000000 !important;
            display: inline-block;
            max-width: none !important;
        }
        .q2w-label.q2w-label--single {
            white-space: nowrap; /* 1개 필드일 때는 가로로 */
        }
        .q2w-label.q2w-label--multi {
            white-space: pre-line; /* 2개 이상이면 줄바꿈 유지 */
        }
        /* 라벨(툴팁) 토글을 위한 CSS */
        .labels-hidden .leaflet-tooltip-pane {
            display: none;
        }
        </style>
        <title></title>
    </head>
    <body>
        <div id="kakao-map"></div>
        <div id="map"></div>
        <script src="js/qgis2web_expressions.js"></script>
        <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=231190ac1aca72ada0b739110d8a0eb4"></script>
        <script src="js/leaflet.js"></script>
        <script src="js/kakao_base.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/jjimenezshaw/Leaflet.Control.Layers.Tree@master/L.Control.Layers.Tree.js"></script>
        <script src="js/leaflet.rotatedMarker.js"></script>
        <script src="js/leaflet.pattern.js"></script>
        <script src="js/leaflet-hash.js"></script>
        <script src="js/Autolinker.min.js"></script>
        <script src="js/rbush.min.js"></script>
        <script src="js/labelgun.min.js"></script>
        <script src="js/labels.js"></script>
        <script src="js/leaflet.photon.js"></script>
        <script src="data/map_data.js"></script>
        <script>
        var map = L.map('map', {
            zoomControl:false, maxZoom:28, minZoom:1
        }).fitBounds([[37.43966984122166,126.86818683641245],[37.6101521616503,127.1412179712234]]);
        // Kakao Roadmap(일반지도/Street) 배경지도 초기화 + Leaflet 뷰 동기화
        initKakaoBaseMap(map, { mapTypeId: 'ROADMAP' });
        var hash = new L.Hash(map);
        map.attributionControl.setPrefix('<a href="https://github.com/tomchadwin/qgis2web" target="_blank">qgis2web</a> &middot; <a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a> &middot; <a href="https://qgis.org">QGIS</a>');
        var autolinker = new Autolinker({truncate: {length: 30, location: 'smart'}});

        // 팝업에 표시할 필드(속성)별 토글 설정
        var popupFieldConfig_map_data = (function() {
            var fields = [
                '감정서번호', '본사/지사', '담당자', '평가사', '건명', '거래처명', '의뢰인', '상태',
                '의뢰일자', '발송일자', '소유자전화', '채무자', '채무자전화', '의뢰문서번', '의뢰부서',
                '제출처', '제출처(Tar', '제출처(T_1', '제출처(T_2', '소유자', '평가목적', '물건종류',
                '주소', '지번주소', '위도', '경도', '지번주소(2', '위도(2)', '경도(2)'
            ];
            var vis = {};
            for (var i = 0; i < fields.length; i++) vis[fields[i]] = true; // 기본: 모두 표시
            return { fields: fields, visible: vis };
        })();

        // 라벨(지도 위 텍스트)에 표시할 필드별 토글 설정
        // - qgis2web 기본 라벨식: 제출처(Tar) / 담당자 / 의뢰일자 / 상태 / 주소
        var labelFieldConfig_map_data = (function() {
            var fields = ['제출처(Tar', '담당자', '의뢰일자', '상태', '주소'];
            var vis = {};
            for (var i = 0; i < fields.length; i++) vis[fields[i]] = true;
            return { fields: fields, visible: vis };
        })();

        function buildPopupContent_map_data(feature) {
            function fmt(v) {
                if (v === null || v === undefined) return '';
                return autolinker.link(String(v).replace(/'/g, '\'').toLocaleString());
            }
            var rows = '';
            var cfg = popupFieldConfig_map_data;
            for (var i = 0; i < cfg.fields.length; i++) {
                var key = cfg.fields[i];
                if (!cfg.visible[key]) continue;
                var val = feature.properties[key];
                if (val === null || val === undefined || val === '') continue;
                rows += '<tr><th>' + key + '</th><td>' + fmt(val) + '</td></tr>';
            }
            return '<table>' + (rows || '<tr><td>표시할 속성이 없습니다.</td></tr>') + '</table>';
        }

        function buildLabelContent_map_data(feature) {
            var cfg = labelFieldConfig_map_data;
            var props = feature && feature.properties ? feature.properties : feature;
            if (!props) return '';
            var parts = [];
            for (var i = 0; i < cfg.fields.length; i++) {
                var key = cfg.fields[i];
                if (!cfg.visible[key]) continue;
                var v = props[key];
                if (v === null || v === undefined || v === '') continue;
                parts.push(String(v));
            }
            if (!parts.length) return '';
            var multi = parts.length > 1;
            var cls = multi ? 'q2w-label q2w-label--multi' : 'q2w-label q2w-label--single';
            var sep = multi ? '\n' : ' ';
            return '<div class="' + cls + '" style="color:#ffffff; font-size:10pt; font-family:\'Open Sans\', sans-serif;">' +
                parts.join(sep) +
                '</div>';
        }
        // remove popup's row if "visible-with-data"
        function removeEmptyRowsFromPopupContent(content, feature) {
         var tempDiv = document.createElement('div');
         tempDiv.innerHTML = content;
         var rows = tempDiv.querySelectorAll('tr');
         for (var i = 0; i < rows.length; i++) {
             var td = rows[i].querySelector('td.visible-with-data');
             var key = td ? td.id : '';
             if (td && td.classList.contains('visible-with-data') && feature.properties[key] == null) {
                 rows[i].parentNode.removeChild(rows[i]);
             }
         }
         return tempDiv.innerHTML;
        }
        // modify popup if contains media
        function addClassToPopupIfMedia(content, popup) {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            var imgTd = tempDiv.querySelector('td img');
            if (imgTd) {
                var src = imgTd.getAttribute('src');
                if (/\.(jpg|jpeg|png|gif|bmp|webp|avif)$/i.test(src)) {
                    popup._contentNode.classList.add('media');
                    setTimeout(function() {
                        popup.update();
                    }, 10);
                } else if (/\.(mp3|wav|ogg|aac)$/i.test(src)) {
                    var audio = document.createElement('audio');
                    audio.controls = true;
                    audio.src = src;
                    imgTd.parentNode.replaceChild(audio, imgTd);
                    popup._contentNode.classList.add('media');
                    setTimeout(function() {
                        popup.setContent(tempDiv.innerHTML);
                        popup.update();
                    }, 10);
                } else if (/\.(mp4|webm|ogg|mov)$/i.test(src)) {
                    var video = document.createElement('video');
                    video.controls = true;
                    video.src = src;
                    video.style.width = "400px";
                    video.style.height = "300px";
                    video.style.maxHeight = "60vh";
                    video.style.maxWidth = "60vw";
                    imgTd.parentNode.replaceChild(video, imgTd);
                    popup._contentNode.classList.add('media');
                    // Aggiorna il popup quando il video carica i metadati
                    video.addEventListener('loadedmetadata', function() {
                        popup.update();
                    });
                    setTimeout(function() {
                        popup.setContent(tempDiv.innerHTML);
                        popup.update();
                    }, 10);
                } else {
                    popup._contentNode.classList.remove('media');
                }
            } else {
                popup._contentNode.classList.remove('media');
            }
        }
        var zoomControl = L.control.zoom({
            position: 'topleft'
        }).addTo(map);
        var bounds_group = new L.featureGroup([]);
        function setBounds() {
        }
        function pop_map_data(feature, layer) {
			layer.on('popupopen', function(e) {
				addClassToPopupIfMedia(e.popup.getContent(), e.popup);
			});
			layer.bindPopup(function() {
                return buildPopupContent_map_data(feature);
            }, { maxHeight: 400 });
        }

        function style_map_data_0() {
            return {
                pane: 'pane_map_data',
                radius: 4.0,
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1,
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(133,182,111,1.0)',
                interactive: true,
            }
        }
        map.createPane('pane_map_data');
        map.getPane('pane_map_data').style.zIndex = 400;
        map.getPane('pane_map_data').style['mix-blend-mode'] = 'normal';
        var layer_map_data = new L.geoJson(json_map_data, {
            attribution: '',
            interactive: true,
            dataVar: 'json_map_data',
            layerName: 'layer_map_data',
            pane: 'pane_map_data',
            onEachFeature: pop_map_data,
            pointToLayer: function (feature, latlng) {
                var context = {
                    feature: feature,
                    variables: {}
                };
                return L.circleMarker(latlng, style_map_data_0(feature));
            },
        });
        bounds_group.addLayer(layer_map_data);
        map.addLayer(layer_map_data);
        
        // QGIS 데이터(오버레이) 토글 컨트롤
        // - 마커(피처)와 텍스트(라벨)를 분리 토글합니다.
        // - 라벨은 Leaflet tooltip pane을 숨기는 "토글용 레이어"로 구현합니다.
        var LabelToggleLayer = L.Layer.extend({
            onAdd: function(m) {
                m.getContainer().classList.remove('labels-hidden');
            },
            onRemove: function(m) {
                m.getContainer().classList.add('labels-hidden');
            }
        });
        var layer_labels_map_data = new LabelToggleLayer();
        // 기본값: 라벨 표시(체크된 상태)
        layer_labels_map_data.addTo(map);

        L.control.layers(
            null,
            {
                '마커': layer_map_data,
                '텍스트(라벨)': layer_labels_map_data
            },
            { collapsed: false, position: 'topright' }
        ).addTo(map);

        // 라벨(텍스트) 필드별 표시/숨김 토글 컨트롤
        (function addLabelFieldToggleControl() {
            var Control = L.Control.extend({
                options: { position: 'topright' },
                onAdd: function(m) {
                    var div = L.DomUtil.create('div', 'popup-field-toggle');
                    div.innerHTML = [
                        '<div class="title">라벨 필드 토글</div>',
                        '<div class="actions">',
                        '  <button type="button" data-action="all">전체</button>',
                        '  <button type="button" data-action="none">해제</button>',
                        '</div>',
                        '<div class="list"></div>'
                    ].join('');

                    L.DomEvent.disableClickPropagation(div);
                    L.DomEvent.disableScrollPropagation(div);

                    var list = div.querySelector('.list');
                    var cfg = labelFieldConfig_map_data;

                    function refreshLabels() {
                        var idx = 0;
                        layer_map_data.eachLayer(function(lyr) {
                            var tt = (lyr.getTooltip && lyr.getTooltip()) ? lyr.getTooltip() : null;
                            if (tt) {
                                tt.setContent(buildLabelContent_map_data(lyr.feature));
                            }
                            idx++;
                        });
                        // labelgun 재계산
                        resetLabels([layer_map_data]);
                    }

                    for (var i = 0; i < cfg.fields.length; i++) {
                        var key = cfg.fields[i];
                        var id = 'labelfield_' + i;
                        var row = document.createElement('label');
                        row.innerHTML = '<input type="checkbox" id="' + id + '" checked> <span>' + key + '</span>';
                        (function(k, checkbox) {
                            checkbox.addEventListener('change', function() {
                                cfg.visible[k] = !!checkbox.checked;
                                refreshLabels();
                            });
                        })(key, row.querySelector('input'));
                        list.appendChild(row);
                    }

                    div.querySelector('[data-action="all"]').addEventListener('click', function() {
                        for (var i = 0; i < cfg.fields.length; i++) cfg.visible[cfg.fields[i]] = true;
                        var inputs = list.querySelectorAll('input[type="checkbox"]');
                        for (var j = 0; j < inputs.length; j++) inputs[j].checked = true;
                        refreshLabels();
                    });
                    div.querySelector('[data-action="none"]').addEventListener('click', function() {
                        for (var i = 0; i < cfg.fields.length; i++) cfg.visible[cfg.fields[i]] = false;
                        var inputs = list.querySelectorAll('input[type="checkbox"]');
                        for (var j = 0; j < inputs.length; j++) inputs[j].checked = false;
                        refreshLabels();
                    });

                    return div;
                }
            });
            map.addControl(new Control());
        })();
        setBounds();
        var i = 0;
        layer_map_data.eachLayer(function(layer) {
            var context = {
                feature: layer.feature,
                variables: {}
            };
            // 라벨은 필드별 토글 설정을 반영해 생성
            layer.bindTooltip(buildLabelContent_map_data(layer.feature), {permanent: true, offset: [-0, -16], className: 'css_map_data'});
            labels.push(layer);
            totalMarkers += 1;
              layer.added = true;
              addLabel(layer, i);
              i++;
        });
        resetLabels([layer_map_data]);
        map.on("zoomend", function(){
            resetLabels([layer_map_data]);
        });
        map.on("layeradd", function(){
            resetLabels([layer_map_data]);
        });
        map.on("layerremove", function(){
            resetLabels([layer_map_data]);
        });
        </script>        
    </body>
</html>
